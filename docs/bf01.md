Mini layout
.quality/
  ledger.db                 # SQLite (authoritative)
scripts/
  qa-plan.go                # discover files → enqueue (hash-ordered), optional shard
  qa-claim.go               # atomically claim next task after :cursor
  qa-complete.go            # mark result + next_due
Makefile

1) SQLite schema (once)
-- .quality/schema.sql
PRAGMA journal_mode=WAL;

CREATE TABLE IF NOT EXISTS qa_ledger (
  repo_id TEXT NOT NULL,
  file_path TEXT NOT NULL,
  path_hash TEXT NOT NULL,          -- sha256 hex of file_path
  content_hash TEXT NOT NULL,       -- sha256 of file contents
  treatment TEXT NOT NULL,          -- e.g., "go_review_v3"
  status TEXT NOT NULL,             -- queued|running|done|failed|skipped
  attempt INTEGER NOT NULL DEFAULT 0,
  result_hash TEXT,
  agent_version TEXT,
  prompt_version TEXT,
  started_at TEXT,
  finished_at TEXT,
  next_due_at TEXT,
  priority REAL DEFAULT 0,
  PRIMARY KEY (repo_id, file_path, content_hash, treatment)
);

CREATE INDEX IF NOT EXISTS idx_ledger_status ON qa_ledger(treatment, status, path_hash);
CREATE INDEX IF NOT EXISTS idx_ledger_due    ON qa_ledger(treatment, next_due_at);

2) Hash & shard rules (simple, fast)

Order: ORDER BY path_hash (sha256 of file_path)

Cursor: last processed path_hash (exclusive)

Shard: use the first byte of path_hash (00–ff). Example: 4 workers

W0: 00–3f, W1: 40–7f, W2: 80–bf, W3: c0–ff

3) qa-plan.go (enqueue/hash/shard)
// scripts/qa-plan.go
package main

import (
  "crypto/sha256"
  "database/sql"
  "encoding/hex"
  "flag"
  "fmt"
  "io"
  "os"
  "path/filepath"
  _ "modernc.org/sqlite"
  "time"
)

func sha256Hex(b []byte) string { h := sha256.Sum256(b); return hex.EncodeToString(h[:]) }
func fileHash(path string) (string, error) {
  f, err := os.Open(path); if err != nil { return "", err }
  defer f.Close()
  h := sha256.New()
  if _, err := io.Copy(h, f); err != nil { return "", err }
  return hex.EncodeToString(h.Sum(nil)), nil
}
func pathHash(path string) string { return sha256Hex([]byte(path)) }

func inShard(hexFirstByte string, shard, of int) bool {
  // hexFirstByte = first two hex chars ("00".."ff")
  b, _ := hex.DecodeString(hexFirstByte)
  v := int(b[0])
  size := 256 / of
  return v >= shard*size && v < (shard+1)*size
}

func main() {
  repo := flag.String("repo", "local", "repo id")
  root := flag.String("root", ".", "scan root")
  treatment := flag.String("treatment", "go_review_v3", "treatment id")
  promptVer := flag.String("prompt", "2025-11-07", "prompt version")
  agentVer := flag.String("agent", "roomba-1", "agent version")
  shard := flag.Int("shard", 0, "this shard index")
  of := flag.Int("of", 1, "total shards")
  dbPath := flag.String("db", ".quality/ledger.db", "sqlite path")
  flag.Parse()

  db, err := sql.Open("sqlite", *dbPath); if err != nil { panic(err) }
  defer db.Close()

  // Ensure schema exists (idempotent)
  if _, err := db.Exec(`PRAGMA journal_mode=WAL;`); err != nil { panic(err) }

  now := time.Now().UTC().Format(time.RFC3339)

  _ = filepath.WalkDir(*root, func(p string, d os.DirEntry, err error) error {
    if err != nil || d.IsDir() { return nil }
    if filepath.Ext(p) != ".go" { return nil } // adjust your filter
    ph := pathHash(p)
    if *of > 1 && !inShard(ph[:2], *shard, *of) { return nil }

    ch, err := fileHash(p); if err != nil { return nil }

    // Upsert queued row if not already done for this content
    _, _ = db.Exec(`
      INSERT OR IGNORE INTO qa_ledger
      (repo_id, file_path, path_hash, content_hash, treatment, status, agent_version, prompt_version, next_due_at, priority)
      VALUES (?, ?, ?, ?, ?, 'queued', ?, ?, ?, 0.0)
    `, *repo, p, ph, ch, *treatment, *agentVer, *promptVer, now)

    return nil
  })

  fmt.Println("plan: queued any new/changed files for shard", *shard, "of", *of)
}

4) qa-claim.go (resume via cursor)
// scripts/qa-claim.go
package main

import (
  "database/sql"
  "flag"
  "fmt"
  "time"
  _ "modernc.org/sqlite"
)

func main() {
  treatment := flag.String("treatment", "go_review_v3", "treatment id")
  cursor := flag.String("cursor", "", "exclusive path_hash lower bound")
  dbPath := flag.String("db", ".quality/ledger.db", "sqlite path")
  limit := flag.Int("n", 1, "how many to claim")
  flag.Parse()

  db, err := sql.Open("sqlite", *dbPath); if err != nil { panic(err) }
  defer db.Close()

  tx, _ := db.Begin()
  rows, err := tx.Query(`
    SELECT repo_id, file_path, path_hash, content_hash
    FROM qa_ledger
    WHERE treatment=? AND status IN ('queued','failed') AND path_hash > ?
    ORDER BY path_hash
    LIMIT ?;
  `, *treatment, *cursor, *limit)
  if err != nil { _ = tx.Rollback(); panic(err) }

  type item struct{ Repo, Path, Hash, Content string }
  var items []item
  for rows.Next() {
    var it item; _ = rows.Scan(&it.Repo, &it.Path, &it.Hash, &it.Content)
    items = append(items, it)
  }
  rows.Close()

  for _, it := range items {
    // optimistic claim
    res, _ := tx.Exec(`
      UPDATE qa_ledger
      SET status='running', started_at=?, attempt=attempt+1
      WHERE repo_id=? AND file_path=? AND content_hash=? AND treatment=? AND status IN ('queued','failed');
    `, time.Now().UTC().Format(time.RFC3339), it.Repo, it.Path, it.Content, *treatment)
    if n, _ := res.RowsAffected(); n == 0 {
      // lost the race; skip
      continue
    }
    fmt.Printf("%s\t%s\t%s\n", it.Hash, it.Path, it.Content) // stdout: path_hash, path, content_hash
  }

  _ = tx.Commit()
}

5) qa-complete.go (finish + schedule next)
// scripts/qa-complete.go
package main

import (
  "database/sql"
  "flag"
  "time"
  _ "modernc.org/sqlite"
)

func main() {
  repo := flag.String("repo", "local", "repo id")
  path := flag.String("path", "", "file path")
  content := flag.String("content", "", "content hash")
  treatment := flag.String("treatment", "go_review_v3", "treatment id")
  result := flag.String("result", "", "normalized result hash")
  revisit := flag.String("revisit", "14 days", "SQLite datetime modifier (e.g., '+14 days')")
  dbPath := flag.String("db", ".quality/ledger.db", "sqlite path")
  status := flag.String("status", "done", "done|failed|skipped")
  flag.Parse()

  db, _ := sql.Open("sqlite", *dbPath)
  defer db.Close()

  _, _ = db.Exec(`
    UPDATE qa_ledger
    SET status=?, result_hash=?, finished_at=?, next_due_at=DATETIME('now', ?)
    WHERE repo_id=? AND file_path=? AND content_hash=? AND treatment=?;
  `, *status, *result, time.Now().UTC().Format(time.RFC3339), "+"+*revisit, *repo, *path, *content, *treatment)
}

6) Makefile (ergonomic)
DB=.quality/ledger.db
SCHE=.quality/schema.sql

init:
	@mkdir -p .quality
	@[ -f $(DB) ] || sqlite3 $(DB) < $(SCHE)

plan:
	go run scripts/qa-plan.go -root=. -treatment=$(T) -shard=$(S) -of=$(OF)

claim:
	go run scripts/qa-claim.go -treatment=$(T) -cursor=$(CURSOR) -n=$(N)

complete:
	go run scripts/qa-complete.go -treatment=$(T) -repo=local -path="$(PATH)" -content=$(CONTENT) -result=$(RESULT) -status=$(STATUS) -revisit=$(REVISIT)

7) Typical workflow

Queue work (4 shards):

make init
make plan T=go_review_v3 S=0 OF=4
make plan T=go_review_v3 S=1 OF=4
make plan T=go_review_v3 S=2 OF=4
make plan T=go_review_v3 S=3 OF=4


Worker loop (per shard):

CURSOR=""
while true; do
  LINE=$(make -s claim T=go_review_v3 CURSOR=$CURSOR N=1)
  [ -z "$LINE" ] && break
  HASH=$(echo $LINE | awk '{print $1}'); PATH=$(echo $LINE | awk '{print $2}'); CONTENT=$(echo $LINE | awk '{print $3}')
  # ...run your LLM/checker against $PATH...
  RESULT_HASH=$(printf "%s" "normalized-result" | shasum -a 256 | awk '{print $1}')
  make -s complete T=go_review_v3 PATH="$PATH" CONTENT=$CONTENT RESULT=$RESULT_HASH STATUS=done REVISIT="14 days"
  CURSOR=$HASH
done

Why this works

Deterministic resume: CURSOR is the last path_hash.

Even parallelism: shard on first byte of path_hash.

Idempotent: primary key includes content_hash; if a file changes, it enqueues as a new row, old rows remain historical.

Portable: zero infra beyond SQLite; runs locally and in CI.

Extensible: add priority, next_due_at cadences, or GitHub Checks without changing the core flow.